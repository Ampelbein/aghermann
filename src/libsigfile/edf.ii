/*
 *       File name:  libsigfile/edf.ii
 *         Project:  Aghermann
 *          Author:  Andrei Zavada <johnhommer@gmail.com>
 * Initial version:  2011-11-21
 *
 *         Purpose:  CEDFFile (big) templated methods
 *
 *         License:  GPL
 */


extern template valarray<TFloat> CEDFFile::get_region_original_( int, size_t, size_t) const;
extern template valarray<TFloat> CEDFFile::get_region_original_( const char*, size_t, size_t) const;
extern template valarray<TFloat> CEDFFile::get_region_filtered_( int, size_t, size_t) const;
extern template valarray<TFloat> CEDFFile::get_region_filtered_( const char*, size_t, size_t) const;
extern template int CEDFFile::put_region_( int, const valarray<TFloat>&, size_t) const;
extern template int CEDFFile::put_region_( const char*, const valarray<TFloat>&, size_t) const;
extern template int CEDFFile::export_original_( int, const char*) const;
extern template int CEDFFile::export_original_( const char*, const char*) const;


template <typename A>
valarray<TFloat>
CEDFFile::
get_region_original_( A h,
		      size_t sa, size_t sz) const
{
	if ( unlikely (_status & (TStatus::bad_header | TStatus::bad_version)) )
		throw invalid_argument("CEDFFile::get_region_original(): broken source");
	if ( unlikely (_mmapping == NULL) )
		throw invalid_argument("CEDFFile::get_region_original(): no data");
	if ( unlikely (sa >= sz || sz > samplerate(h) * recording_time()) )
		throw range_error("CEDFFile::get_region_original(): bad region");

	valarray<TFloat> recp;

	const SSignal& H = (*this)[h];
	size_t	r0    =                        (   sa) / H.samples_per_record,
		r_cnt = (size_t) ceilf( (float)(sz-sa) / H.samples_per_record);

	int16_t* tmp;
	tmp = (int16_t*)malloc( r_cnt * H.samples_per_record * 2);  // 2 is sizeof(sample) sensu edf

	while ( r_cnt-- )
		memcpy( &tmp[ r_cnt * H.samples_per_record ],

			(char*)_mmapping + header_length
			+ (r0 + r_cnt) * _total_samples_per_record * 2	// full records before
			+ H._at * 2,				// offset to our samples

			H.samples_per_record * 2);	// our precious ones

	recp.resize( sz - sa);

      // repackage for shipping, and scale
	size_t sa_off = sa - r0 * H.samples_per_record;
	for ( size_t s = 0; s < recp.size(); ++s )
		recp[s] = tmp[sa_off + s] * H.scale;

	free( tmp);

	return recp;
}



template <typename Th>
valarray<TFloat>
CEDFFile::
get_region_filtered_( Th h,
		      size_t smpla, size_t smplz) const
{
	valarray<TFloat> recp =
		get_region_original( h, smpla, smplz);
	if ( recp.size() == 0 )
		return valarray<TFloat> (0);
	// and zeromean
       	recp -= (recp.sum() / recp.size());

	const SSignal& H = (*this)[h];

      // artifacts
	size_t this_samplerate = H.samples_per_record / data_record_size;
	for ( auto &A : H.artifacts() ) {
		if ( unlikely (A.a >= smplz) )
			break;
		size_t	run = A.z - A.a,
			window = min( run, this_samplerate),
			t;
		if ( unlikely (A.z > smplz) )
			run = smplz - A.a;
		valarray<TFloat>
			W (run);

		if ( run > window ) {
			// construct a vector of multipliers using an INVERTED windowing function on the
			// first and last windows of the run
			size_t	t0;
			for ( t = 0; t < window/2; ++t )
				W[t] = (1 - sigproc::winf[(size_t)H.artifacts.dampen_window_type]( t, window));
			t0 = run-window;  // start of the last window but one
			for ( t = window/2; t < window; ++t )
				W[t0 + t] = (1 - sigproc::winf[(size_t)H.artifacts.dampen_window_type]( t, window));
			// AND, connect mid-first to mid-last windows (at lowest value of the window)
			TFloat minimum = sigproc::winf[(size_t)H.artifacts.dampen_window_type]( window/2, window);
			W[ slice(window/2, run-window, 1) ] =
				(1. - minimum);
		} else  // run is shorter than samplerate (1 sec)
			for ( t = 0; t < window; ++t )
				W[t] = (1 - sigproc::winf[(size_t)H.artifacts.dampen_window_type]( t, window));

		// now gently apply the multiplier vector onto the artifacts
		recp[ slice(A.a, run, 1) ] *= (W * (TFloat)H.artifacts.factor);
	}

      // filters
	if ( H.filters.low_pass_cutoff > 0. && H.filters.high_pass_cutoff > 0. &&
	     H.filters.low_pass_order > 0 && H.filters.high_pass_order > 0 ) {
		auto tmp (exstrom::band_pass(
				  recp, this_samplerate,
				  H.filters.high_pass_cutoff, H.filters.low_pass_cutoff,
				  H.filters.low_pass_order, true));
		recp = tmp;
	} else {
		if ( H.filters.low_pass_cutoff > 0. && H.filters.low_pass_order > 0 ) {
			auto tmp (exstrom::low_pass(
					  recp, this_samplerate,
					  H.filters.low_pass_cutoff, H.filters.low_pass_order, true));
			recp = tmp;
		}
		if ( H.filters.high_pass_cutoff > 0. && H.filters.high_pass_order > 0 ) {
			auto tmp (exstrom::high_pass(
					  recp, this_samplerate,
					  H.filters.high_pass_cutoff, H.filters.high_pass_order, true));
			recp = tmp;
		}
	}

	switch ( H.filters.notch_filter ) {
	case SFilterPack::TNotchFilter::at50Hz:
		recp = exstrom::band_stop( recp, this_samplerate,
					   48, 52, 1, true);
	    break;
	case SFilterPack::TNotchFilter::at60Hz:
		recp = exstrom::band_stop( recp, this_samplerate,
					   58, 62, 1, true);
	    break;
	case SFilterPack::TNotchFilter::none:
	    break;
	}

	// filters happen to append samples, so
	return recp[ slice (0, smplz-smpla, 1)];
}





template <typename A>
int
CEDFFile::
put_region_( A h,
	     const valarray<TFloat>& src,
	     size_t offset) const
{
	if ( unlikely (_status & (TStatus::bad_header | TStatus::bad_version)) )
		throw invalid_argument("CEDFFile::put_region_(): broken source");
	if ( unlikely (_mmapping == NULL) )
		throw invalid_argument("CEDFFile::put_region_(): no data");
	if ( unlikely (offset >= samplerate(h) * recording_time()) )
		throw range_error("CEDFFile::put_region_(): offset beyond end of file");
	if ( unlikely (offset + src.size() > samplerate(h) * recording_time()) ) {
		fprintf( stderr, "CEDFFile::put_region_(): attempt to write past end of file (%zu + %zu > %zu * %lu)\n",
			 offset, src.size(), samplerate(h), recording_time());
		throw range_error("CEDFFile::put_region_(): attempt to write past end of file");
	}

	const SSignal& H = (*this)[h];
	size_t	r0    =                            offset  / H.samples_per_record,
		r_cnt = (size_t) ceilf( (double)src.size() / H.samples_per_record);

	valarray<int16_t> tmp (src.size());
	for ( size_t i = 0; i < tmp.size(); ++i )
		tmp[i] = // clamp
			agh::alg::value_within(
				(double)src[i] / H.scale, (double)INT16_MIN, (double)INT16_MAX);

	size_t r;
	for ( r = 0; r < r_cnt - 1; ++r ) // minus one
		memcpy( (char*)_mmapping + header_length
			+ (r0 + r) * _total_samples_per_record * 2	// full records before
			+ H._at * 2,				// offset to our samples

			&tmp[ r * H.samples_per_record ],

			H.samples_per_record * 2);	// our precious ones
	// last record is underfull
	memcpy( (char*)_mmapping + header_length
		+ (r0 + r) * _total_samples_per_record * 2
		+ H._at * 2,

		&tmp[ r * H.samples_per_record ],

		(tmp.size() - r * H.samples_per_record) * 2);

	return 0;
}



template <typename Th>
int
CEDFFile::
put_signal_( Th h,
	     const valarray<TFloat>& src) const
{
	return put_region_( h, src, (size_t)0);
}


template <typename Th>
int
CEDFFile::
export_original_( Th h,
		  const char *fname) const
{
	valarray<TFloat> signal = get_signal_original( h);
	FILE *fd = fopen( fname, "w");
	if ( fd ) {
		for ( size_t i = 0; i < signal.size(); ++i )
			fprintf( fd, "%g\n", signal[i]);
		fclose( fd);
		return 0;
	} else
		return -1;
}


template <typename Th>
int
CEDFFile::
export_filtered_( Th h,
		  const char *fname) const
{
	valarray<TFloat> signal = get_signal_filtered( h);
	FILE *fd = fopen( fname, "w");
	if ( fd ) {
		for ( size_t i = 0; i < signal.size(); ++i )
			fprintf( fd, "%g\n", signal[i]);
		fclose( fd);
		return 0;
	} else
		return -1;
}

// Local Variables:
// Mode: c++
// indent-tabs-mode: 8
// End:

