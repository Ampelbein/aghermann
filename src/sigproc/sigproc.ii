// ;-*-C++-*-
/*
 *       File name:  sigproc/sigproc.ii
 *         Project:  Aghermann
 *          Author:  Andrei Zavada <johnhommer@gmail.com>
 * Initial version:  2012-03-11
 *
 *         Purpose:  various signal processing functions (templates)
 *
 *         License:  GPL
 */

extern template void smooth( valarray<TFloat>&, size_t);
extern template void normalize( valarray<TFloat>&);
extern template valarray<TFloat> derivative( const valarray<TFloat>&);
extern template size_t envelope( const valarray<TFloat>&, size_t, size_t, float, valarray<TFloat>&, valarray<TFloat>&, vector<size_t>*, vector<size_t>*);
extern template valarray<TFloat> dzcdf( const valarray<TFloat>&, size_t, float, float, size_t);
extern template CPattern<TFloat>::CPattern( const valarray<TFloat>&, size_t, size_t, size_t, const SPatternParamPack&, float, float, float);
extern template size_t CPattern<TFloat>::find( const valarray<TFloat>&, const valarray<TFloat>&, const valarray<TFloat>&, ssize_t, int);
extern template size_t CPattern<TFloat>::find( const valarray<TFloat>&, ssize_t, int);
extern template double sig_diff( const valarray<TFloat>&, const valarray<TFloat>&, int);
extern template double phase_diff( const valarray<TFloat>&, const valarray<TFloat>&, size_t, size_t, size_t, float, float, unsigned, size_t);



template <typename T>
void
smooth( valarray<T>& a, size_t side)
{
	if ( side == 0 )
		return;

	size_t	both = side * 2 + 1;

	valarray<T> tmp (a.size() + 2*side);
	tmp[ slice (0              , side, 1)     ] = a[0];
	tmp[ slice (side           , a.size(), 1) ] = a;
	tmp[ slice (side + a.size(), side, 1)     ] = a[a.size()-1];

	valarray<T> dst (a.size());
	for ( size_t i = 0; i < a.size(); ++i )
		dst[i] = valarray<T>{tmp[ slice (i, both, 1) ]}.sum() / both;

	a = dst;
}



template <typename T>
void
normalize( valarray<T>& a)
{
	a /= a.max();
}


template <typename T>
valarray<T>
derivative( const valarray<T>& a)
{
	valarray<T> out (a.size());
	for ( size_t i = 1; i < a.size(); ++i )
		out[i-1] = a[i] - a[i-1];
	return out;
}







template <typename T>
size_t
envelope( const valarray<T>& in,
	  size_t dh,  // tightness
	  size_t samplerate,
	  double dt,
	  valarray<T>& env_l,  // return interpolated
	  valarray<T>& env_u,
	  // optionally also return vector of points
	  vector<size_t> *envv_lp = nullptr,
	  vector<size_t> *envv_up = nullptr)
{
	size_t	i, j,
		n_samples = in.size();

	vector<size_t>
		envv_l,
		envv_u;

	// always put a point at start
	envv_l.push_back( 0);
	envv_u.push_back( 0);

	for ( i = dh; i < n_samples-dh; ++i ) {
		for ( j = 1; j <= dh; ++j )
			if ( in[i-j] <= in[i] )  // [i] is not a local min
				goto inner_continue;
		for ( j = 1; j <= dh; ++j )
			if ( in[i+j] <= in[i] )  // [i] is not
				goto inner_continue;
		envv_l.push_back( i);
		continue;
	inner_continue:
		for ( j = 1; j <= dh; ++j )
			if ( in[i-j] >= in[i] )  // [i] is not a local max
				goto outer_continue;
		for ( j = 1; j <= dh; ++j )
			if ( in[i+j] >= in[i] )  // [i] is not
				goto outer_continue;
		envv_u.push_back( i);
	outer_continue:
		;
	}

	// put a point at end
	envv_l.push_back( i);
	envv_u.push_back( i);

	if ( envv_l.size() > 5 && envv_u.size() > 5 ) {
		env_l = interpolate( envv_l, samplerate, in, dt);
		env_u = interpolate( envv_u, samplerate, in, dt);
		if ( envv_lp )
			(*envv_lp) = envv_l;
		if ( envv_up )
			(*envv_up) = envv_u;
		return envv_u.size();
	} else
		return 0;
}






template <typename T>
valarray<T>
dzcdf( const valarray<T>& in,
       size_t samplerate,
       float dt,
       float sigma,
       size_t smooth_side)
{
	size_t i;

	valarray<T>
		tmp (in),
		derivative (0., in.size());

	smooth( tmp, smooth_side);

      // get derivative
	for ( i = 1; i < in.size(); ++i )
		derivative[i-1] = (tmp[i] - tmp[i-1]);

      // collect zerocrossings
	vector<size_t> izx;
	for ( i = 1; i < in.size(); ++i )
		if ( sign( derivative[i-1]) != sign( derivative[i]) )
			izx.push_back( i);

      // prepare structures for interpolation
	size_t out_size = (float)in.size()/samplerate / dt;
	vector<size_t> xi (out_size);
	valarray<T> y (in.size());

      // calculate the bloody zcdf
	float	window = 4*dt; // half a second, good enough
	float	t = 0., tdiff;
	size_t	I = 0, J;
	for ( i = 0; i < out_size; ++i ) {
		xi[i] = i * dt * samplerate;
		for ( J = I; J > 0; --J ) {
			tdiff = (float)izx[J]/samplerate - t;
			if ( tdiff >  window )
				continue;
			if ( tdiff < -window )
				break;
			y[ xi[i] ] += exp( -gsl_pow_2(tdiff) / gsl_pow_2(sigma));
		}
		for ( ; J < izx.size(); ++J ) {
			tdiff = (float)izx[J]/samplerate - t;
			if ( tdiff < -window )
				continue;
			if ( tdiff >  window )
				break;
			y[ xi[i] ] += exp( -gsl_pow_2(tdiff) / gsl_pow_2(sigma));
		}
		t = i*dt;
		I = J;
	}
	return interpolate( xi, samplerate, y, 1./samplerate);
}









template <typename T>
CPattern<T>::
CPattern (const valarray<T>& pattern,
	  size_t _context_before, size_t _context_after,
	  size_t _samplerate,
	  const SPatternParamPack& params_,
	  float _a, float _b, float _c)
      : params (params_),
	a (_a), b (_b), c (_c),
	match_a (NAN), match_b (NAN), match_c (NAN),
	samplerate (_samplerate),
	context_before (_context_before), context_after (_context_after)
{
	if ( context_before + context_after >= pattern.size() )
		throw invalid_argument ("pattern.size too small");
	course =
		exstrom::low_pass(
			pattern, samplerate,
			params.bwf_cutoff, params.bwf_order, true);

	valarray<T> env_u, env_l;
	envelope( pattern, params.env_tightness, samplerate,
		  1./samplerate,
		  env_l, env_u);
	breadth.resize( env_u.size());
	breadth = env_u - env_l;

	dzcd =
		dzcdf( pattern, samplerate,
		       params.dzcdf_step, params.dzcdf_sigma, params.dzcdf_smooth);
}




template <typename T>
size_t
CPattern<T>::
find( const valarray<T>& fcourse,
      const valarray<T>& fbreadth,
      const valarray<T>& fdzcd,
      ssize_t start,
      int inc)
{
	if ( inc == 0 || inc > (ssize_t)fcourse.size() ) {
		fprintf( stderr, "CSignalPattern::find(): bad search increment: %d\n", inc);
		return (size_t)-1;
	}

	T	diff_course,
		diff_breadth,
		diff_dzcd;

	// printf( "course.size = %zu, fcourse.size = %zu, start = %zu\n",
	//  	course.size(), fcourse.size(), start);
	ssize_t	iz = (inc > 0) ? fcourse.size() - size_with_context() : 0;
	size_t	essential_part = size_essential();
	// bool	looking_further = false;
	// T	ax, bx, cx;
	for ( ssize_t i = start; (inc > 0) ? i < iz : i > iz; i += inc ) {
		diff_course = diff_breadth = diff_dzcd = 0.;
		for ( size_t j = 0; j < essential_part; ++j ) {
			diff_course  += fdim( course [context_before + j], fcourse [i+j]);
			diff_breadth += fdim( breadth[context_before + j], fbreadth[i+j]);
			diff_dzcd    += fdim( dzcd   [context_before + j], fdzcd   [i+j]);
		}

		diff_course  /= essential_part;
		diff_breadth /= essential_part;
		diff_dzcd    /= essential_part;

		// if ( i % 250 == 0 ) printf( "at %zu diff_course = %g,\tdiff_breadth = %g\t diff_dzcdf = %g\n", i, diff_course, diff_breadth, diff_dzcd);
		if ( diff_course < a && diff_breadth < b && diff_dzcd < c ) {
			// if ( !looking_further ) {
			// 	looking_further = true;
			match_a = diff_course, match_b = diff_breadth, match_c = diff_dzcd;
			return i;
		}
	}

	return (size_t)-1;
}


template <typename T>
size_t
CPattern<T>::
find( const valarray<T>& signal,
      ssize_t start,
      int inc)
{
      // low-pass signal being searched, too
	valarray<T> fcourse =
		exstrom::low_pass( signal, samplerate,
				   params.bwf_cutoff, params.bwf_order, true);

      // prepare for comparison by other criteria:
	// signal envelope and breadth
	valarray<T> env_u, env_l;
	envelope( signal, params.env_tightness, samplerate,
		  1./samplerate, env_u, env_l);
	valarray<T> fbreadth (env_u.size());
	fbreadth = env_u - env_l;

	// dzcdf
	valarray<T> fdzcd =
		dzcdf( signal, samplerate,
		       params.dzcdf_step, params.dzcdf_sigma, params.dzcdf_smooth);

	return find( fcourse, fbreadth, fdzcd,
		     start, inc);
}





template <typename T>
double
sig_diff( const valarray<T>& a, const valarray<T>& b,
	  int d)
{
	double diff = 0.;
	if ( d > 0 )
		for ( size_t i =  d; i < a.size(); ++i )
			diff += fdim( a[i - d], b[i]);
	else
		for ( size_t i = -d; i < a.size(); ++i )
			diff += fdim( a[i], b[i + d]);
	return diff;
}

template <typename T>
double
phase_diff( const valarray<T>& sig1,
	    const valarray<T>& sig2,
	    size_t samplerate,
	    size_t sa, size_t sz,
	    float fa, float fz,
	    unsigned order,
	    size_t scope)
{
	if ( order == 0 )
		throw invalid_argument ("NExstrom::phase_diff(): order == 0");
      // bandpass sig1 and sig2
	valarray<T>
		sig1p = exstrom::band_pass( valarray<T> (&sig1[sa], sz - sa), samplerate, fa, fz, order, true),
		sig2p = exstrom::band_pass( valarray<T> (&sig2[sa], sz - sa), samplerate, fa, fz, order, true);

      // slide one against the other a little
	double	diff = INFINITY, old_diff, diff_min = INFINITY;
	int	dist, dist_min = 0;
	// go east
	dist = 0;
	do {
		old_diff = diff;
		if ( (diff = sig_diff( sig1p, sig2p, dist)) < diff_min )
			diff_min = diff, dist_min = dist;
	} while ( -(dist--) < (int)scope && old_diff > diff );  // proceed until the first minimum
	// and west
	dist = 0, old_diff = INFINITY;
	do {
		old_diff = diff;
		if ( (diff = sig_diff( sig1p, sig2p, dist)) < diff_min )
			diff_min = diff, dist_min = dist;
	} while (  (dist++) < (int)scope && old_diff > diff );

	return (double)dist_min / samplerate;
}


// eof
