// ;-*-C++-*-
/*
 *       File name:  sigproc/sigproc.ii
 *         Project:  Aghermann
 *          Author:  Andrei Zavada <johnhommer@gmail.com>
 * Initial version:  2012-03-11
 *
 *         Purpose:  various signal processing functions (templates)
 *
 *         License:  GPL
 */

extern template void smooth( valarray<TFloat>&, size_t);
extern template void normalize( valarray<TFloat>&);
extern template valarray<TFloat> derivative( const valarray<TFloat>&);
// this one is used for both T = float and double
extern template size_t envelope( const SSignalRef<float>&, size_t, double, valarray<float>*, valarray<float>*, vector<size_t>*, vector<size_t>*);
extern template size_t envelope( const SSignalRef<double>&, size_t, double, valarray<double>*, valarray<double>*, vector<size_t>*, vector<size_t>*);
extern template valarray<TFloat> dzcdf( const SSignalRef<TFloat>&, double, double, size_t);
extern template double sig_diff( const valarray<TFloat>&, const valarray<TFloat>&, int);
extern template double phase_diff( const SSignalRef<TFloat>&, const SSignalRef<TFloat>&, size_t, size_t, double, double, unsigned, size_t);



template <typename T>
void
smooth( valarray<T>& a, size_t side)
{
	if ( side == 0 )
		return;

	size_t	both = side * 2 + 1;

	valarray<T> tmp (a.size() + 2*side);
	tmp[ slice (0              , side, 1)     ] = a[0];
	tmp[ slice (side           , a.size(), 1) ] = a;
	tmp[ slice (side + a.size(), side, 1)     ] = a[a.size()-1];

	valarray<T> dst (a.size());
	for ( size_t i = 0; i < a.size(); ++i )
		dst[i] = valarray<T>{tmp[ slice (i, both, 1) ]}.sum() / both;

	a = dst;
}



template <typename T>
void
normalize( valarray<T>& a)
{
	a /= a.max();
}


template <typename T>
valarray<T>
derivative( const valarray<T>& a)
{
	valarray<T> out (a.size());
	for ( size_t i = 1; i < a.size(); ++i )
		out[i-1] = a[i] - a[i-1];
	return out;
}







template <typename T>
size_t
envelope( const SSignalRef<T>& in,
	  size_t dh,  // tightness
	  double dt,
	  valarray<T>* env_lp = nullptr,    // return interpolated
	  valarray<T>* env_up = nullptr,
	  vector<size_t> *mini_p = nullptr, // return vector of extremum indices
	  vector<size_t> *maxi_p = nullptr)
{
	size_t	i, j,
		n_samples = in.signal.size();

	vector<size_t>
		mini,
		maxi;

	// always put a point at start
	mini.push_back( 0);
	maxi.push_back( 0);

	for ( i = dh; i < n_samples-dh; ++i ) {
		for ( j = 1; j <= dh; ++j )
			if ( in.signal[i-j] <= in.signal[i] )  // [i] is not a local min
				goto inner_continue;
		for ( j = 1; j <= dh; ++j )
			if ( in.signal[i+j] <= in.signal[i] )  // [i] is not
				goto inner_continue;
		mini.push_back( i);
		continue;
	inner_continue:
		for ( j = 1; j <= dh; ++j )
			if ( in.signal[i-j] >= in.signal[i] )  // [i] is not a local max
				goto outer_continue;
		for ( j = 1; j <= dh; ++j )
			if ( in.signal[i+j] >= in.signal[i] )  // [i] is not
				goto outer_continue;
		maxi.push_back( i);
	outer_continue:
		;
	}

	// put a point at end
	mini.push_back( i);
	maxi.push_back( i);

	if ( mini.size() > 5 && maxi.size() > 5 ) {
		if ( env_lp )
			*env_lp = interpolate( mini, in.samplerate, in.signal, dt);
		if ( env_up )
			*env_up = interpolate( maxi, in.samplerate, in.signal, dt);
		if ( mini_p )
			*mini_p = mini;
		if ( maxi_p )
			*maxi_p = maxi;

		return maxi.size();
	} else
		return 0;
}






template <typename T>
valarray<T>
dzcdf( const SSignalRef<T>& in,
       double dt,
       double sigma,
       size_t smooth_side)
{
	size_t i;

	valarray<T>
		tmp (in.signal),
		deriv = derivative( in.signal);

	smooth( tmp, smooth_side);

      // collect zerocrossings
	vector<size_t> izx;
	for ( i = 1; i < in.signal.size(); ++i )
		if ( agh::alg::sign( deriv[i-1]) != agh::alg::sign( deriv[i]) )
			izx.push_back( i);

      // prepare structures for interpolation
	size_t out_size = (double)in.signal.size()/in.samplerate / dt;
	vector<size_t> xi (out_size);
	valarray<T> y (in.signal.size());

      // calculate the bloody zcdf
	double	window = 4*dt; // half a second, good enough
	double	t = 0., tdiff;
	size_t	I = 0, J;
	for ( i = 0; i < out_size; ++i ) {
		xi[i] = i * dt * in.samplerate;
		for ( J = I; J > 0; --J ) {
			tdiff = (double)izx[J]/in.samplerate - t;
			if ( tdiff >  window )
				continue;
			if ( tdiff < -window )
				break;
			y[ xi[i] ] += exp( -gsl_pow_2(tdiff) / gsl_pow_2(sigma));
		}
		for ( ; J < izx.size(); ++J ) {
			tdiff = (double)izx[J]/in.samplerate - t;
			if ( tdiff < -window )
				continue;
			if ( tdiff >  window )
				break;
			y[ xi[i] ] += exp( -gsl_pow_2(tdiff) / gsl_pow_2(sigma));
		}
		t = i*dt;
		I = J;
	}
	return interpolate( xi, in.samplerate, y, 1./in.samplerate);
}





template <typename T>
double
sig_diff( const valarray<T>& a, const valarray<T>& b,
	  int d)
{
	double diff = 0.;
	if ( d > 0 )
		for ( size_t i =  d; i < a.size(); ++i )
			diff += fdim( a[i - d], b[i]);
	else
		for ( size_t i = -d; i < a.size(); ++i )
			diff += fdim( a[i], b[i + d]);
	return diff;
}

template <typename T>
double
phase_diff( const SSignalRef<T>& sig1,
	    const SSignalRef<T>& sig2,
	    size_t sa, size_t sz,
	    double fa, double fz,
	    unsigned order,
	    size_t scope)
{
	if ( sig1.samplerate != sig2.samplerate )
		throw invalid_argument ("sigproc::phase_diff(): sig1.samplerate != sig2.samplerate");
	if ( order == 0 )
		throw invalid_argument ("sigproc::phase_diff(): order == 0");

      // bandpass sig1 and sig2
	valarray<T>
		sig1p = exstrom::band_pass( valarray<T> (&sig1.signal[sa], sz - sa), sig1.samplerate, fa, fz, order, true),
		sig2p = exstrom::band_pass( valarray<T> (&sig2.signal[sa], sz - sa), sig2.samplerate, fa, fz, order, true);

      // slide one against the other a little
	double	diff = INFINITY, old_diff, diff_min = INFINITY;
	int	dist, dist_min = 0;
	// go east
	dist = 0;
	do {
		old_diff = diff;
		if ( (diff = sig_diff( sig1p, sig2p, dist)) < diff_min )
			diff_min = diff, dist_min = dist;
	} while ( -(dist--) < (int)scope && old_diff > diff );  // proceed until the first minimum
	// and west
	dist = 0, old_diff = INFINITY;
	do {
		old_diff = diff;
		if ( (diff = sig_diff( sig1p, sig2p, dist)) < diff_min )
			diff_min = diff, dist_min = dist;
	} while (  (dist++) < (int)scope && old_diff > diff );

	return (double)dist_min / sig1.samplerate;
}


// eof
