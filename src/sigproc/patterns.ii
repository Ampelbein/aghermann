// ;-*-C++-*-
/*
 *       File name:  sigproc/patterns.ii
 *         Project:  Aghermann
 *          Author:  Andrei Zavada <johnhommer@gmail.com>
 * Initial version:  2013-01-09
 *
 *         Purpose:  CPattern templates
 *
 *         License:  GPL
 */

extern template CPattern<TFloat>::CPattern( const sigproc::SSignalRef<TFloat>&, size_t, size_t, const SPatternPPack&);
extern template int CPattern<TFloat>::do_search( const valarray<TFloat>&, const valarray<TFloat>&, const valarray<TFloat>&, const valarray<TFloat>&, size_t);
extern template int CPattern<TFloat>::do_search( const sigproc::SSignalRef<TFloat>&, size_t);
extern template int CPattern<TFloat>::do_search( const valarray<TFloat>&, size_t);


template <typename T>
int
CPattern<T>::
do_search( const valarray<T>& fenv_u,
	   const valarray<T>& fenv_l,
	   const valarray<T>& ftarget_freq,
	   const valarray<T>& fdzcdf,
	   size_t inc)
{
	size_t fsize = ftarget_freq.size();
	if ( inc == 0 || inc > fsize ) {
		fprintf( stderr, "%s: bad search increment: %zu\n", __FUNCTION__, inc);
		return -1;
	}

	// make it (each time) field-specific
	crit_linear_unity =
		fenv_u.sum() / fenv_u.size() -
		fenv_l.sum() / fenv_l.size();
	crit_dzcdf_unity =
		fdzcdf.sum() / fdzcdf.size();

	printf( "field = %zu, thing = %zu(%zu), size_essential = %zu\n",
	 	fsize, ptarget_freq.signal.size(),
		penv.centre(SPatternPPack<T>::env_tightness).size(), size_essential());

	// here be all diffs
	diff.resize( fsize);

	size_t	essential_part = size_essential();
	for ( ssize_t i = 0; i+inc < fsize - essential_part; i += inc ) {
		auto	p0 = penv.centre( SPatternPPack<T>::env_scope),
			p1 = penv.breadth( SPatternPPack<T>::env_scope),
			p2 = ptarget_freq( SPatternPPack<T>::bwf_ffrom,
					   SPatternPPack<T>::bwf_fupto,
					   SPatternPPack<T>::bwf_order),
			p3 = pdzcdf( SPatternPPack<T>::dzcdf_step,
				     SPatternPPack<T>::dzcdf_sigma,
				     SPatternPPack<T>::dzcdf_smooth);

		for ( size_t j = 0; j < essential_part; ++j ) {
			get<0>(diff[i]) += gsl_pow_2( p0[ctx_before + j]
					      - (fenv_u[i+j] + fenv_l[i+j])/2);
			get<1>(diff[i]) += gsl_pow_2( p1[ctx_before + j]
					      - (fenv_u[i+j] - fenv_l[i+j]));
			get<2>(diff[i]) += gsl_pow_2( p2[ctx_before + j]
					      - ftarget_freq[i+j]);
			get<3>(diff[i]) += gsl_pow_2( p3[ctx_before + j]
					      - fdzcdf[i+j]);
		}

		get<0>(diff[i]) = sqrt(get<0>(diff[i]) / essential_part) / crit_linear_unity; // normalise
		get<1>(diff[i]) = sqrt(get<1>(diff[i]) / essential_part) / crit_linear_unity;
		get<2>(diff[i]) = sqrt(get<2>(diff[i]) / essential_part) / crit_linear_unity;
		get<3>(diff[i]) = sqrt(get<3>(diff[i]) / essential_part) / crit_dzcdf_unity;

		// if ( i % 250 == 0 ) printf( "at %zu diff_course = %g,\tdiff_breadth = %g\t diff_dzcdf = %g\n", i, diff_course, diff_breadth, diff_dzcd);
		// if ( diff[i].good_enough(SPatternPPack<T>::criteria) )
		//	match_indices.push_back(i);
		// printf( " %17zu : %4g  %4g  %4g  %4g\n",
		// 	i, diff[0], diff[1], diff[2], diff[3]);
	}

	return 0;
}


template <typename T>
int
CPattern<T>::
do_search( const sigproc::SSignalRef<T>& signal,
	   size_t inc)
{
	if ( signal.samplerate != samplerate )
		throw invalid_argument( "CPattern::find( SSignalRef&): not same samplerate");

	return do_search( signal.signal,
			  inc);
}

template <typename T>
int
CPattern<T>::
do_search( const valarray<T>& signal,
	   size_t inc)
{
	valarray<T> fenv_u, fenv_l;
	sigproc::envelope(
		{signal, samplerate}, SPatternPPack<T>::env_scope,
		1./samplerate, &fenv_u, &fenv_l);

	auto ftarget_freq =
		exstrom::band_pass(
			signal, samplerate,
			SPatternPPack<T>::bwf_ffrom,
			SPatternPPack<T>::bwf_fupto,
			SPatternPPack<T>::bwf_order, true);
	auto fdzcdf =
		sigproc::dzcdf(
			sigproc::SSignalRef<T> {signal, samplerate},
			SPatternPPack<T>::dzcdf_step,
			SPatternPPack<T>::dzcdf_sigma,
			SPatternPPack<T>::dzcdf_smooth);

	return do_search( fenv_u, fenv_l, ftarget_freq, fdzcdf,
			  inc);
}


// eof
