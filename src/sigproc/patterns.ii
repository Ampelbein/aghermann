// ;-*-C++-*-
/*
 *       File name:  sigproc/patterns.ii
 *         Project:  Aghermann
 *          Author:  Andrei Zavada <johnhommer@gmail.com>
 * Initial version:  2013-01-09
 *
 *         Purpose:  CPattern templates
 *
 *         License:  GPL
 */

extern template CPattern<TFloat>::CPattern( const sigproc::SSignalRef<TFloat>&, size_t, size_t,
					    const SPatternPPack&);
extern template size_t CPattern<TFloat>::find( const valarray<TFloat>&,
					       const valarray<TFloat>&,
					       const valarray<TFloat>&,
					       const valarray<TFloat>&,
					       ssize_t, int);
extern template size_t CPattern<TFloat>::find( const sigproc::SSignalRef<TFloat>&,
					       ssize_t, int);
extern template size_t CPattern<TFloat>::find( const valarray<TFloat>&,
					       ssize_t, int);


template <typename T>
size_t
CPattern<T>::
find( const valarray<T>& fenv_u,
      const valarray<T>& fenv_l,
      const valarray<T>& ftarget_freq,
      const valarray<T>& fdzcdf,
      ssize_t start,
      int inc)
{
	if ( inc == 0 || inc > (ssize_t)ftarget_freq.size() ) {
		fprintf( stderr, "CPattern::find(): bad search increment: %d\n", inc);
		return (size_t)-1;
	}

	// make it (each time) field-specific
	crit_linear_unity =
		fenv_u.sum() / fenv_u.size() -
		fenv_l.sum() / fenv_l.size();
	crit_dzcdf_unity =
		fdzcdf.sum() / fdzcdf.size();

	printf( "field = %zu, thing = %zu(%zu), start = %zu, size_essential = %zu\n",
	 	ftarget_freq.size(), ptarget_freq.signal.size(),
		penv.centre(SPatternPPack<T>::env_tightness).size(),  start, size_essential());
	// printf( " %4g  %4g  %4g  %4g\n",
	// 	SPatternPPack<T>::criteria.get<0>(), SPatternPPack<T>::criteria[1], SPatternPPack<T>::criteria[2], SPatternPPack<T>::criteria[3]);

	// here be all diffs
	diff.resize( ftarget_freq.size());
	match_indices.resize(0);

	ssize_t	iz = (inc > 0) ? ftarget_freq.size() - size_with_context() : 0;
	size_t	essential_part = size_essential();
	for ( ssize_t i = start; (inc > 0) ? i+inc < iz : i+inc > iz; i += inc ) {
		auto	p0 = penv.centre( SPatternPPack<T>::env_tightness),
			p1 = penv.breadth( SPatternPPack<T>::env_tightness),
			p2 = ptarget_freq( SPatternPPack<T>::bwf_ffrom,
					   SPatternPPack<T>::bwf_fupto,
					   SPatternPPack<T>::bwf_order),
			p3 = pdzcdf( SPatternPPack<T>::dzcdf_step,
				     SPatternPPack<T>::dzcdf_sigma,
				     SPatternPPack<T>::dzcdf_smooth);

		for ( size_t j = 0; j < essential_part; ++j ) {
			get<0>(diff[i]) += gsl_pow_2( p0[ctx_before + j]
					      - (fenv_u[i+j] + fenv_l[i+j])/2);
			get<1>(diff[i]) += gsl_pow_2( p1[ctx_before + j]
					      - (fenv_u[i+j] - fenv_l[i+j]));
			get<2>(diff[i]) += gsl_pow_2( p2[ctx_before + j]
					      - ftarget_freq[i+j]);
			get<3>(diff[i]) += gsl_pow_2( p3[ctx_before + j]
					      - fdzcdf[i+j]);
		}

		get<0>(diff[i]) = sqrt(get<0>(diff[i]) / essential_part) / crit_linear_unity; // normalise
		get<1>(diff[i]) = sqrt(get<1>(diff[i]) / essential_part) / crit_linear_unity;
		get<2>(diff[i]) = sqrt(get<2>(diff[i]) / essential_part) / crit_linear_unity;
		get<3>(diff[i]) = sqrt(get<3>(diff[i]) / essential_part) / crit_dzcdf_unity;

		// if ( i % 250 == 0 ) printf( "at %zu diff_course = %g,\tdiff_breadth = %g\t diff_dzcdf = %g\n", i, diff_course, diff_breadth, diff_dzcd);
		if ( diff[i].good_enough(SPatternPPack<T>::criteria) )
			match_indices.push_back(i);
		// printf( " %17zu : %4g  %4g  %4g  %4g\n",
		// 	i, diff[0], diff[1], diff[2], diff[3]);
	}

	return match_indices.size();
}


template <typename T>
size_t
CPattern<T>::
find( const sigproc::SSignalRef<T>& signal,
      ssize_t start,
      int inc)
{
	if ( signal.samplerate != samplerate )
		throw invalid_argument( "CPattern::find( SSignalRef&): not same samplerate");

	return find( signal.signal,
		     start, inc);
}

template <typename T>
size_t
CPattern<T>::
find( const valarray<T>& signal,
      ssize_t start,
      int inc)
{
	valarray<T> fenv_u, fenv_l;
	sigproc::envelope(
		{signal, samplerate}, SPatternPPack<T>::env_tightness,
		1./samplerate, &fenv_u, &fenv_l);

	auto ftarget_freq =
		exstrom::band_pass(
			signal, samplerate,
			SPatternPPack<T>::bwf_ffrom,
			SPatternPPack<T>::bwf_fupto,
			SPatternPPack<T>::bwf_order, true);
	auto fdzcdf =
		sigproc::dzcdf(
			sigproc::SSignalRef<T> {signal, samplerate},
			SPatternPPack<T>::dzcdf_step,
			SPatternPPack<T>::dzcdf_sigma,
			SPatternPPack<T>::dzcdf_smooth);

	return find( fenv_u, fenv_l, ftarget_freq, fdzcdf,
		     start, inc);
}


// eof
